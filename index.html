<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Battle Royale Arena</title>
    <style>
        :root {
            --color-bg-primary: #1a1a2e;
            --color-bg-secondary: #16213e;
            --color-text-primary: #eee;
            --color-accent: #e94560;
            --color-success: #0f3460;
            --color-warning: #f39c12;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, var(--color-bg-primary) 0%, var(--color-bg-secondary) 100%);
            color: var(--color-text-primary);
            overflow: hidden;
            height: 100vh;
        }

        #gameContainer {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        #gameHeader {
            padding: 15px 20px;
            background: rgba(0, 0, 0, 0.3);
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid var(--color-accent);
        }

        .playerStats {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .stat {
            display: flex;
            flex-direction: column;
            gap: 3px;
        }

        .statLabel {
            font-size: 12px;
            opacity: 0.7;
            text-transform: uppercase;
        }

        .statValue {
            font-size: 18px;
            font-weight: bold;
            color: var(--color-accent);
        }

        .weaponDisplay {
            background: rgba(233, 69, 96, 0.2);
            padding: 8px 16px;
            border-radius: 8px;
            font-weight: bold;
            border: 2px solid var(--color-accent);
        }

        #gameCanvas {
            flex: 1;
            display: block;
            background: radial-gradient(ellipse at center, #1a1a1a 0%, #0a0a0a 100%);
        }

        #gameControls {
            padding: 15px 20px;
            background: rgba(0, 0, 0, 0.3);
            display: flex;
            justify-content: center;
            gap: 15px;
            border-top: 2px solid var(--color-accent);
        }

        .controlBtn {
            padding: 10px 20px;
            background: var(--color-accent);
            color: white;
            border: none;
            border-radius: 6px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
        }

        .controlBtn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(233, 69, 96, 0.5);
        }

        .controlBtn:active {
            transform: scale(0.95);
        }

        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 40px 60px;
            border-radius: 15px;
            text-align: center;
            border: 3px solid var(--color-accent);
            display: none;
        }

        #gameOver h2 {
            font-size: 36px;
            margin-bottom: 20px;
            color: var(--color-accent);
        }

        #gameOver p {
            font-size: 18px;
            margin-bottom: 25px;
        }

        .instructions {
            background: rgba(233, 69, 96, 0.1);
            padding: 15px;
            border-radius: 8px;
            font-size: 13px;
            line-height: 1.6;
            margin-top: 15px;
            text-align: left;
        }

        .instructions strong {
            color: var(--color-accent);
        }

        .healthBar {
            width: 150px;
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            overflow: hidden;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        .healthFill {
            height: 100%;
            background: linear-gradient(90deg, #e94560 0%, #ff6b6b 100%);
            transition: width 0.3s;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="gameHeader">
            <div class="playerStats">
                <div class="stat">
                    <span class="statLabel">Health</span>
                    <div class="healthBar">
                        <div class="healthFill" id="healthBar" style="width: 100%;"></div>
                    </div>
                </div>
                <div class="stat">
                    <span class="statLabel">Kills</span>
                    <span class="statValue" id="killCount">0</span>
                </div>
                <div class="stat">
                    <span class="statLabel">Enemies</span>
                    <span class="statValue" id="enemyCount">3</span>
                </div>
            </div>
            <div class="weaponDisplay" id="weaponDisplay">
                ðŸ¤œ FISTS
            </div>
        </div>
        <canvas id="gameCanvas"></canvas>
        <div id="gameControls">
            <div class="instructions">
                <strong>Controls:</strong> WASD/Arrow Keys to Move & Aim | I to Attack | K to Jump | L to Dodge | O for Ultimate Skill | Break boxes/crates to upgrade weapons!<br>
                <strong>Weapon Progression:</strong> Fists â†’ Knife â†’ Pistol â†’ Auto Gun â†’ RPG | <strong>Ultimate:</strong> <span id="ultimateCharge" style="color: #f39c12;">0/100</span>
            </div>
        </div>
    </div>

    <div id="gameOver">
        <h2 id="gameOverTitle">Victory!</h2>
        <p id="gameOverText">You defeated all enemies!</p>
        <button class="controlBtn" onclick="location.reload()">Play Again</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight - 140;

        const WEAPONS = [
            { name: 'ðŸ¤œ FISTS', damage: 15, range: 50, fireRate: 300, icon: 'ðŸ¤œ', projectile: false },
            { name: 'ðŸ”ª KNIFE', damage: 30, range: 70, fireRate: 250, icon: 'ðŸ”ª', projectile: false },
            { name: 'ðŸ”« PISTOL', damage: 35, range: 200, fireRate: 600, icon: 'ðŸ”«', projectile: true, speed: 8 },
            { name: 'ðŸ”« AUTO GUN', damage: 20, range: 250, fireRate: 150, icon: 'ðŸ”«', projectile: true, speed: 10 },
            { name: 'ðŸš€ RPG', damage: 100, range: 300, fireRate: 1500, icon: 'ðŸš€', projectile: true, speed: 6, explosive: true }
        ];

        class Player {
            constructor(x, y, isPlayer = false) {
                this.x = x;
                this.y = y;
                this.width = 30;
                this.height = 30;
                this.speed = 4;
                this.health = 100;
                this.maxHealth = 100;
                this.weaponLevel = 0;
                this.isPlayer = isPlayer;
                this.angle = 0;
                this.color = isPlayer ? '#e94560' : '#3498db';
                this.lastShot = 0;
                this.kills = 0;
                this.aiTimer = 0;
                this.aiTargetX = x;
                this.aiTargetY = y;
                this.isJumping = false;
                this.jumpHeight = 0;
                this.isDodging = false;
                this.dodgeTime = 0;
                this.dodgeInvulnerable = false;
                this.hitFlash = false;
                this.hitFlashTime = 0;
            }

            draw() {
                const scale = 1 - (this.jumpHeight / 150);
                const shadow = this.jumpHeight / 2;
                
                ctx.save();
                
                ctx.fillStyle = 'rgba(0, 0, 0, ' + (0.3 - this.jumpHeight / 200) + ')';
                ctx.beginPath();
                ctx.ellipse(this.x, this.y + shadow, this.width/2 * (1 + this.jumpHeight/80), 8, 0, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.translate(this.x, this.y - this.jumpHeight);
                ctx.rotate(this.angle);
                ctx.scale(scale, scale);
                
                if (this.isDodging) {
                    ctx.globalAlpha = 0.5;
                }
                
                const gradient = ctx.createLinearGradient(-this.width/2, -this.height/2, this.width/2, this.height/2);
                if (this.hitFlash) {
                    gradient.addColorStop(0, '#ffffff');
                    gradient.addColorStop(1, '#ffffff');
                } else {
                    const lightColor = this.isPlayer ? '#ff6b8a' : '#5ab4e8';
                    const darkColor = this.isPlayer ? '#c72d50' : '#2875a3';
                    gradient.addColorStop(0, lightColor);
                    gradient.addColorStop(1, darkColor);
                }
                ctx.fillStyle = gradient;
                ctx.fillRect(-this.width/2, -this.height/2, this.width, this.height);
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.fillRect(-this.width/2 + 2, -this.height/2 + 2, this.width - 4, this.height - 4);
                
                ctx.fillStyle = '#fff';
                ctx.shadowColor = this.isPlayer ? '#e94560' : '#3498db';
                ctx.shadowBlur = 5;
                ctx.fillRect(this.width/4, -this.height/2 - 10, 3, 10);
                ctx.shadowBlur = 0;
                
                ctx.restore();

                const barWidth = 40;
                const barHeight = 5;
                const healthPercent = this.health / this.maxHealth;
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(this.x - barWidth/2, this.y - this.height - 10, barWidth, barHeight);
                
                ctx.fillStyle = healthPercent > 0.5 ? '#2ecc71' : healthPercent > 0.25 ? '#f39c12' : '#e74c3c';
                ctx.fillRect(this.x - barWidth/2, this.y - this.height - 10, barWidth * healthPercent, barHeight);
            }

            move(dx, dy) {
                this.x += dx * this.speed;
                this.y += dy * this.speed;
                
                this.x = Math.max(this.width/2, Math.min(canvas.width - this.width/2, this.x));
                this.y = Math.max(this.height/2, Math.min(canvas.height - this.height/2, this.y));
            }

            takeDamage(damage) {
                if (this.dodgeInvulnerable) {
                    return false;
                }
                this.health -= damage;
                this.hitFlash = true;
                this.hitFlashTime = Date.now();
                if (this.health <= 0) {
                    this.health = 0;
                    return true;
                }
                return false;
            }

            useUltimate() {
                const ultimateRadius = 200;
                hitEffects.push(new UltimateEffect(this.x, this.y));
                
                enemies.forEach((enemy, index) => {
                    const distance = Math.sqrt((enemy.x - this.x) ** 2 + (enemy.y - this.y) ** 2);
                    if (distance < ultimateRadius) {
                        if (enemy.takeDamage(150)) {
                            enemies.splice(index, 1);
                            this.kills++;
                        }
                    }
                });
                
                obstacles.forEach((obstacle, obsIndex) => {
                    const distance = Math.sqrt((obstacle.x - this.x) ** 2 + (obstacle.y - this.y) ** 2);
                    if (distance < ultimateRadius) {
                        if (obstacle.takeDamage(150)) {
                            obstacles.splice(obsIndex, 1);
                        }
                    }
                });
            }

            updateHitFlash() {
                if (this.hitFlash && Date.now() - this.hitFlashTime > 100) {
                    this.hitFlash = false;
                }
            }

            jump() {
                if (!this.isJumping) {
                    this.isJumping = true;
                    this.jumpHeight = 0;
                }
            }

            dodge() {
                if (!this.isDodging) {
                    this.isDodging = true;
                    this.dodgeInvulnerable = true;
                    this.dodgeTime = Date.now();
                    this.speed = 8;
                }
            }

            updateJump() {
                if (this.isJumping) {
                    this.jumpHeight += 3;
                    if (this.jumpHeight >= 40) {
                        this.jumpHeight = 40;
                    }
                    if (this.jumpHeight >= 40) {
                        setTimeout(() => {
                            const fallInterval = setInterval(() => {
                                this.jumpHeight -= 3;
                                if (this.jumpHeight <= 0) {
                                    this.jumpHeight = 0;
                                    this.isJumping = false;
                                    clearInterval(fallInterval);
                                }
                            }, 16);
                        }, 200);
                    }
                }
            }

            updateDodge() {
                if (this.isDodging) {
                    if (Date.now() - this.dodgeTime > 300) {
                        this.isDodging = false;
                        this.dodgeInvulnerable = false;
                        this.speed = 4;
                    }
                }
            }

            shoot(targetX, targetY, currentTime) {
                const weapon = WEAPONS[this.weaponLevel];
                if (currentTime - this.lastShot < weapon.fireRate) return null;
                
                this.lastShot = currentTime;
                
                if (weapon.projectile) {
                    const angle = Math.atan2(targetY - this.y, targetX - this.x);
                    return new Projectile(this.x, this.y, angle, weapon, this.isPlayer);
                } else {
                    const dx = targetX - this.x;
                    const dy = targetY - this.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < weapon.range) {
                        return { melee: true, damage: weapon.damage, range: weapon.range };
                    }
                }
                return null;
            }

            aiUpdate(target, obstacles, currentTime) {
                this.aiTimer++;
                
                if (this.aiTimer % 60 === 0) {
                    const dx = target.x - this.x;
                    const dy = target.y - this.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance > 150) {
                        this.aiTargetX = this.x + dx * 0.3 + (Math.random() - 0.5) * 100;
                        this.aiTargetY = this.y + dy * 0.3 + (Math.random() - 0.5) * 100;
                    } else {
                        const angle = Math.atan2(dy, dx) + (Math.random() - 0.5) * Math.PI / 2;
                        this.aiTargetX = this.x + Math.cos(angle) * 80;
                        this.aiTargetY = this.y + Math.sin(angle) * 80;
                    }
                }
                
                const dx = this.aiTargetX - this.x;
                const dy = this.aiTargetY - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 5) {
                    this.move(dx / distance, dy / distance);
                }
                
                this.angle = Math.atan2(target.y - this.y, target.x - this.x);
                
                if (Math.random() < 0.02) {
                    return this.shoot(target.x, target.y, currentTime);
                }
                
                return null;
            }
        }

        class HitEffect {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = 5;
                this.maxRadius = 25;
                this.alpha = 1;
                this.complete = false;
            }

            update() {
                this.radius += 2;
                this.alpha -= 0.05;
                if (this.radius >= this.maxRadius || this.alpha <= 0) {
                    this.complete = true;
                }
            }

            draw() {
                ctx.save();
                ctx.globalAlpha = this.alpha;
                ctx.strokeStyle = '#ff0000';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();
            }
        }

        class UltimateEffect {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = 10;
                this.maxRadius = 200;
                this.alpha = 1;
                this.complete = false;
            }

            update() {
                this.radius += 8;
                this.alpha -= 0.02;
                if (this.radius >= this.maxRadius || this.alpha <= 0) {
                    this.complete = true;
                }
            }

            draw() {
                ctx.save();
                ctx.globalAlpha = this.alpha;
                
                ctx.strokeStyle = '#f39c12';
                ctx.lineWidth = 5;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.stroke();
                
                ctx.strokeStyle = '#e94560';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius * 0.8, 0, Math.PI * 2);
                ctx.stroke();
                
                ctx.fillStyle = '#ffff00';
                ctx.globalAlpha = this.alpha * 0.3;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            }
        }

        class MuzzleFlash {
            constructor(x, y, angle) {
                this.x = x;
                this.y = y;
                this.angle = angle;
                this.life = 3;
            }

            update() {
                this.life--;
            }

            draw() {
                if (this.life <= 0) return;
                
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                
                ctx.fillStyle = '#ffff00';
                ctx.globalAlpha = 0.8;
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(20, -5);
                ctx.lineTo(20, 5);
                ctx.closePath();
                ctx.fill();
                
                ctx.fillStyle = '#ff8800';
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(15, -3);
                ctx.lineTo(15, 3);
                ctx.closePath();
                ctx.fill();
                
                ctx.restore();
            }
        }

        class Projectile {
            constructor(x, y, angle, weapon, isPlayerProjectile) {
                this.x = x;
                this.y = y;
                this.angle = angle;
                this.speed = weapon.speed;
                this.damage = weapon.damage;
                this.range = weapon.range;
                this.distanceTraveled = 0;
                this.isPlayerProjectile = isPlayerProjectile;
                this.explosive = weapon.explosive || false;
                this.radius = this.explosive ? 8 : 5;
            }

            update() {
                const dx = Math.cos(this.angle) * this.speed;
                const dy = Math.sin(this.angle) * this.speed;
                this.x += dx;
                this.y += dy;
                this.distanceTraveled += this.speed;
                
                return this.distanceTraveled < this.range && 
                       this.x > 0 && this.x < canvas.width && 
                       this.y > 0 && this.y < canvas.height;
            }

            draw() {
                ctx.save();
                
                const gradient = ctx.createRadialGradient(
                    this.x - this.radius/3, this.y - this.radius/3, 0,
                    this.x, this.y, this.radius
                );
                
                if (this.isPlayerProjectile) {
                    gradient.addColorStop(0, '#ff9fb0');
                    gradient.addColorStop(1, '#e94560');
                } else {
                    gradient.addColorStop(0, '#7dc8f0');
                    gradient.addColorStop(1, '#3498db');
                }
                
                ctx.shadowColor = this.isPlayerProjectile ? '#e94560' : '#3498db';
                ctx.shadowBlur = 10;
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                
                if (this.explosive) {
                    ctx.strokeStyle = '#f39c12';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
                
                ctx.restore();
            }
        }

        class Obstacle {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.width = type === 'box' ? 40 : 60;
                this.height = type === 'box' ? 40 : 60;
                this.health = type === 'box' ? 50 : 100;
                this.maxHealth = this.health;
            }

            draw() {
                ctx.save();
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.fillRect(this.x - this.width/2 + 3, this.y - this.height/2 + 3, this.width, this.height);
                
                const gradient = ctx.createLinearGradient(
                    this.x - this.width/2, this.y - this.height/2,
                    this.x + this.width/2, this.y + this.height/2
                );
                
                if (this.type === 'box') {
                    gradient.addColorStop(0, '#a0692f');
                    gradient.addColorStop(1, '#6b4423');
                } else {
                    gradient.addColorStop(0, '#95a5a6');
                    gradient.addColorStop(1, '#5a6c70');
                }
                
                ctx.fillStyle = gradient;
                ctx.fillRect(this.x - this.width/2, this.y - this.height/2, this.width, this.height);
                
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                ctx.strokeRect(this.x - this.width/2, this.y - this.height/2, this.width, this.height);
                
                if (this.type === 'box') {
                    ctx.fillStyle = 'rgba(101, 67, 33, 0.5)';
                    ctx.fillRect(this.x - this.width/2 + 5, this.y - this.height/2 + 5, this.width - 10, this.height - 10);
                }
                
                ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.fillRect(this.x - this.width/2, this.y - this.height/2, this.width, 3);
                
                ctx.restore();
                
                const healthPercent = this.health / this.maxHealth;
                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.fillRect(this.x - this.width/2, this.y - this.height/2, this.width * healthPercent, 3);
            }

            takeDamage(damage) {
                this.health -= damage;
                return this.health <= 0;
            }

            collidesWith(obj) {
                return Math.abs(this.x - obj.x) < (this.width + obj.width) / 2 &&
                       Math.abs(this.y - obj.y) < (this.height + obj.height) / 2;
            }
        }

        const keys = {};
        let mouseX = 0, mouseY = 0;
        let mouseDown = false;

        let attackKey = false;
        let jumpKey = false;
        let dodgeKey = false;
        let ultimateKey = false;
        let ultimateCharge = 0;
        const ULTIMATE_MAX = 100;
        
        document.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
            if (e.key.toLowerCase() === 'i') attackKey = true;
            if (e.key.toLowerCase() === 'k') jumpKey = true;
            if (e.key.toLowerCase() === 'l') dodgeKey = true;
            if (e.key.toLowerCase() === 'o') ultimateKey = true;
        });
        document.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
            if (e.key.toLowerCase() === 'i') attackKey = false;
            if (e.key.toLowerCase() === 'k') jumpKey = false;
            if (e.key.toLowerCase() === 'l') dodgeKey = false;
            if (e.key.toLowerCase() === 'o') ultimateKey = false;
        });
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX - rect.left;
            mouseY = e.clientY - rect.top;
        });
        canvas.addEventListener('mousedown', () => mouseDown = true);
        canvas.addEventListener('mouseup', () => mouseDown = false);

        const player = new Player(canvas.width / 2, canvas.height / 2, true);
        const enemies = [];
        const projectiles = [];
        const obstacles = [];
        const hitEffects = [];
        const muzzleFlashes = [];

        for (let i = 0; i < 3; i++) {
            const angle = (i / 3) * Math.PI * 2;
            const distance = 300;
            enemies.push(new Player(
                canvas.width / 2 + Math.cos(angle) * distance,
                canvas.height / 2 + Math.sin(angle) * distance,
                false
            ));
        }

        for (let i = 0; i < 15; i++) {
            const type = Math.random() > 0.5 ? 'box' : 'crate';
            obstacles.push(new Obstacle(
                Math.random() * (canvas.width - 100) + 50,
                Math.random() * (canvas.height - 100) + 50,
                type
            ));
        }

        function checkCollision(obj1, obj2, threshold = 30) {
            const dx = obj1.x - obj2.x;
            const dy = obj1.y - obj2.y;
            return Math.sqrt(dx * dx + dy * dy) < threshold;
        }

        function updateUI() {
            document.getElementById('healthBar').style.width = (player.health / player.maxHealth * 100) + '%';
            document.getElementById('killCount').textContent = player.kills;
            document.getElementById('enemyCount').textContent = enemies.length;
            document.getElementById('weaponDisplay').textContent = WEAPONS[player.weaponLevel].name;
            document.getElementById('ultimateCharge').textContent = `${Math.floor(ultimateCharge)}/${ULTIMATE_MAX}`;
            document.getElementById('ultimateCharge').style.color = ultimateCharge >= ULTIMATE_MAX ? '#2ecc71' : '#f39c12';
        }

        function gameOver(won) {
            document.getElementById('gameOverTitle').textContent = won ? 'VICTORY!' : 'GAME OVER';
            document.getElementById('gameOverText').textContent = won ? 
                `You defeated all enemies with ${player.kills} kills!` :
                `You were defeated! Kills: ${player.kills}`;
            document.getElementById('gameOver').style.display = 'block';
        }

        function gameLoop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const currentTime = Date.now();
            
            let dx = 0, dy = 0;
            if (keys['w'] || keys['arrowup']) dy -= 1;
            if (keys['s'] || keys['arrowdown']) dy += 1;
            if (keys['a'] || keys['arrowleft']) dx -= 1;
            if (keys['d'] || keys['arrowright']) dx += 1;
            
            if (dx !== 0 || dy !== 0) {
                const magnitude = Math.sqrt(dx * dx + dy * dy);
                player.move(dx / magnitude, dy / magnitude);
            }
            
            if (dx !== 0 || dy !== 0) {
                player.angle = Math.atan2(dy, dx);
            } else if (enemies.length > 0) {
                let closestEnemy = enemies[0];
                let minDist = Infinity;
                enemies.forEach(enemy => {
                    const dist = Math.sqrt((enemy.x - player.x) ** 2 + (enemy.y - player.y) ** 2);
                    if (dist < minDist) {
                        minDist = dist;
                        closestEnemy = enemy;
                    }
                });
                player.angle = Math.atan2(closestEnemy.y - player.y, closestEnemy.x - player.x);
            }
            
            if (jumpKey) {
                player.jump();
                jumpKey = false;
            }
            
            if (dodgeKey) {
                player.dodge();
                dodgeKey = false;
            }
            
            player.updateJump();
            player.updateDodge();
            player.updateHitFlash();

            enemies.forEach(enemy => {
                enemy.updateHitFlash();
            });
            
            if (ultimateKey && player.health > 0 && ultimateCharge >= ULTIMATE_MAX) {
                player.useUltimate();
                ultimateCharge = 0;
                ultimateKey = false;
            }
            
            if (attackKey && player.health > 0) {
                const targetX = player.x + Math.cos(player.angle) * 100;
                const targetY = player.y + Math.sin(player.angle) * 100;
                const shot = player.shoot(targetX, targetY, currentTime);
                if (shot) {
                    if (shot.projectile) {
                        projectiles.push(shot);
                        muzzleFlashes.push(new MuzzleFlash(player.x, player.y, player.angle));
                    } else if (shot.melee) {
                        hitEffects.push(new HitEffect(player.x + Math.cos(player.angle) * 30, player.y + Math.sin(player.angle) * 30));
                        
                        enemies.forEach((enemy, index) => {
                            if (checkCollision(player, enemy, shot.range)) {
                                if (enemy.takeDamage(shot.damage)) {
                                    enemies.splice(index, 1);
                                    player.kills++;
                                    ultimateCharge = Math.min(ULTIMATE_MAX, ultimateCharge + 20);
                                    
                                    if (player.weaponLevel < WEAPONS.length - 1) {
                                        player.weaponLevel++;
                                    }
                                }
                            }
                        });
                        
                        obstacles.forEach((obstacle, obsIndex) => {
                            if (Math.abs(player.x - obstacle.x) < shot.range && Math.abs(player.y - obstacle.y) < shot.range) {
                                if (obstacle.takeDamage(shot.damage)) {
                                    obstacles.splice(obsIndex, 1);
                                    
                                    if (Math.random() > 0.6 && player.weaponLevel < WEAPONS.length - 1) {
                                        player.weaponLevel++;
                                    }
                                }
                            }
                        });
                    }
                }
            }
            
            enemies.forEach((enemy, enemyIndex) => {
                const shot = enemy.aiUpdate(player, obstacles, currentTime);
                if (shot && shot.projectile) {
                    projectiles.push(shot);
                } else if (shot && shot.melee) {
                    if (checkCollision(player, enemy, shot.range) && player.takeDamage(shot.damage)) {
                        gameOver(false);
                    }
                }
            });
            
            projectiles.forEach((proj, index) => {
                if (!proj.update()) {
                    projectiles.splice(index, 1);
                    return;
                }
                
                if (proj.isPlayerProjectile) {
                    enemies.forEach((enemy, enemyIndex) => {
                        if (checkCollision(proj, enemy, 20)) {
                            hitEffects.push(new HitEffect(enemy.x, enemy.y));
                            if (enemy.takeDamage(proj.damage)) {
                                enemies.splice(enemyIndex, 1);
                                projectiles.splice(index, 1);
                                player.kills++;
                                ultimateCharge = Math.min(ULTIMATE_MAX, ultimateCharge + 20);
                                
                                if (player.weaponLevel < WEAPONS.length - 1 && Math.random() > 0.7) {
                                    player.weaponLevel++;
                                }
                            } else {
                                projectiles.splice(index, 1);
                            }
                        }
                    });
                } else {
                    if (checkCollision(proj, player, 20)) {
                        hitEffects.push(new HitEffect(player.x, player.y));
                        if (player.takeDamage(proj.damage)) {
                            projectiles.splice(index, 1);
                            gameOver(false);
                        } else {
                            projectiles.splice(index, 1);
                        }
                    }
                }
                
                obstacles.forEach((obstacle, obsIndex) => {
                    if (checkCollision(proj, obstacle, 25)) {
                        hitEffects.push(new HitEffect(obstacle.x, obstacle.y));
                        if (obstacle.takeDamage(proj.damage)) {
                            obstacles.splice(obsIndex, 1);
                            
                            if (Math.random() > 0.6 && player.weaponLevel < WEAPONS.length - 1) {
                                player.weaponLevel++;
                            }
                        }
                        projectiles.splice(index, 1);
                    }
                });
            });

            hitEffects.forEach((effect, index) => {
                effect.update();
                if (effect.complete) {
                    hitEffects.splice(index, 1);
                }
            });

            muzzleFlashes.forEach((flash, index) => {
                flash.update();
                if (flash.life <= 0) {
                    muzzleFlashes.splice(index, 1);
                }
            });
            
            obstacles.forEach(obstacle => obstacle.draw());
            hitEffects.forEach(effect => effect.draw());
            projectiles.forEach(proj => proj.draw());
            muzzleFlashes.forEach(flash => flash.draw());
            enemies.forEach(enemy => enemy.draw());
            if (player.health > 0) player.draw();
            
            updateUI();
            
            if (enemies.length === 0 && player.health > 0) {
                gameOver(true);
                return;
            }
            
            if (player.health > 0) {
                requestAnimationFrame(gameLoop);
            }
        }

        gameLoop();

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight - 140;
        });
    </script>
</body>
</html>
